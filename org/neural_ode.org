#+SETUPFILE: ./hugo_setup.org
#+TITLE: Neural Ordinary Differential Equations
#+HUGO_TAGS: machine-learning deep-learning

This is a paper review of the NIPS 2018 best paper award-winning paper
[[https://arxiv.org/abs/1806.07366][Neural Ordinary Differential Equations]].

* Motivation

In this section, I motivate the benefits of Neural Ordinary
Differential Equations (ODEs). Many physical phenomena can be modeled
naturally with the language of differential equations. These include
populations of predator and prey, or in physics with regards to motion
between bodies. Differential equations shine where it is easier to
model changes in the systems over time rather than the value
themselves.

Consider a simple pendulum, with the dampening effect of air
resistance. One can model the dynamic system using a second-order ODE,
as such:

\begin{equation}
  \ddot{\theta}(t) = - \mu \dot{\theta}(t) - \frac{g}{L}\sin\left( \theta(t) \right)
\end{equation}

There are infinitely many solutions to this ODE, but generally only
one that satisfies the initial conditions at $t = 0$. We'd like to
find $\theta(t)$ for some any $t$. It turns out finding the solutions
to these problems are hard, and numerical methods are required to find
the solutions. These numerical methods range from simplest Euler's
method, to Runge-Kutta methods.

Suppose now that we have some dynamic system (for example, the
pendulum), and we have measured some data from the system
$\hat{\theta}(t)$ (the pendulum's position, at time $t$). *Can a neural
network learn the dynamics of the system from data?* 

Regular neural networks states are transformed by a series of discrete
transformations:

\begin{equation}
\mathbf{h}_{t+1} = f(\mathbf{h}_t)
\end{equation}

where $f$ could be of different kinds of layers, including convolutional
and dense layers. $t$ can be interpreted as a time index, transforming
some input data at $t=0$ to an output in a different space at $t=N$,
where there are $N$ layers.

Because neural networks apply discrete transformations, to learn
dynamical systems with (recurrent) neural networks, one must
discretize the time steps, for example through binning the
observations into fixed time intervals. Expressing time as a discrete
variable can be unnatural, for example, in processes where events
occur at irregular intervals. This means that the current
state-of-the-art neural networks are still unable to model continuous
sequential data.

* The Analogy to Residual Neural Networks 

In neural networks, every layer introduces error that compounds through the neural
network, hindering overall performance. The only way to bypass this is
to add more layers, and limit the complexity of each step. This means
that the highest performing neural networks would have infinite
layers, and infinitesimal step-changes, an infeasible task.

To address this problem, deep residual neural networks were presented
cite:he15_deep_resid_learn_image_recog. 

Instead of learning $h_{t+1} = f(h_t, \theta_t)$, deep residual neural
networks now learn the difference between the layers: $h_{t+1} = h_t +
f(h_t, \theta_t)$. For example, feed-forward residual neural networks
have a composition that looks like these:

\begin{align*}
  h_1 &= h_0 + f(h_0, \theta_0) \\
  h_2 &= h_1 + f(h_1, \theta_1) \\
  h_3 &= h_2 + f(h_2, \theta_2) \\
  \dots \\
  h_{t+1} &= h_t + f(h_t, \theta_t) \\
\end{align*}

These iterative updates correspond to the infinitesimal step-changes
described earlier, and can be seen to be analogous to an Euler
discretization of a continuous transformation
cite:lu17_beyon_finit_layer_neural_networ. In the limit, one can
instead represent the continuous dynamics between the hidden units
using an ordinary differential equation (ODE) specified by some neural
network:

\begin{equation}
  \frac{d\mathbf{h}(t)}{dt} = f(\mathbf{h}(t), t, \theta)
\end{equation}

where the neural network has parameters $\theta$. The equivalent of
having $T$ layers in the network, is finding the solution to this ODE at
time $T$.

The analogy between ODEs and neural networks is not new, and has been
discussed in previous papers
cite:lu17_beyon_finit_layer_neural_networ,haber17_stabl_archit_deep_neural_networ.
This paper popularized this idea, by proposing a new method for
scalable backpropagation through ODE solvers, allowing end-to-end
training within larger models.

* The NeuralODE Model

The Neural ODE model introduces a new type of block the authors term the
ODE block. This block replaces the ResNet-like skip connections, with
an ODE that models the neural network's dynamics:

\begin{equation}
  \frac{d\mathbf{h}(t)}{dt} = f(\mathbf{h}(t), t, \theta)
\end{equation}

This ODE can then be solved using a black box solver, with the output
state being used to compute the loss:

\begin{equation}
  L(\mathbf{z}(t_1)) = L\left( \mathbf{z}(t_0) + \int_{t_0}^{t_1}
    f(\mathbf{z}(t), t, \theta)dt \right) =
  L(\textrm{ODESolve}(\mathbf{z}(t_0), f, t_0, t_1, \theta))
\end{equation}

The loss is used to compute gradients, but, as mentioned in the paper,
performing backpropagation through the ODE solver incurs too high a
memory cost. Here, I illustrate why, with a simple example.

Suppose we use the Euler method to solve the ODE. The Euler solver update
step is similar to a ResNet block:

\begin{equation}
  h_{t+1} =  h_t + NN(h_{t})
\end{equation}

Continuous-depth networks will have large $t$. Despite the ODE solvers
being easily differentiable, backpropagating through the neural
network in this case is equivalent to computing and storing the
gradients in a $t$-depth ResNet. With higher-order ODE
solvers, the memory requirements are also higher.

The paper proposes a method of computing gradients by solving a
second, augmented ODE backwards in time, that is applicable to all ODE
solvers.

* Gradient Computation via Adjoint Sensitivity Analysis
Sensitivity analysis defines a new ODE whose solution gives the
gradients to the cost function w.r.t. the parameters, and solves this
secondary ODE. cite:rackauckas19_diffeq

bibliography:neural_ode.bib


